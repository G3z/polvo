// Generated by CoffeeScript 1.4.0
var Chunk, Script, Toaster, define, require;

Script = (function() {
  var cached, started;

  started = {};

  cached = {};

  Script.prototype.id = null;

  Script.prototype.el = null;

  Script.prototype.url = null;

  Script.prototype.done = null;

  Script.prototype.error = null;

  function Script(id, url, done, error, timeout, is_non_amd) {
    var _this = this;
    this.id = id;
    this.url = url;
    this.done = done;
    this.error = error;
    this.is_non_amd = is_non_amd;
    console.log("new script: " + id + " -> " + url);
    setTimeout(function() {
      return _this.load();
    }, timeout);
  }

  Script.prototype.load = function() {
    var head, reg,
      _this = this;
    if (Toaster.MAP[this.id] != null) {
      this.url = Toaster.MAP[this.id];
    } else {
      this.url = this.id;
    }
    if (!/^http/m.test(this.url)) {
      reg = new RegExp("(^" + (Toaster.BASE_URL.replace('/', '\\/')) + ")");
      if (!reg.test(this.url)) {
        this.url = "" + Toaster.BASE_URL + this.url;
      }
    }
    if ((this.url.indexOf('.js')) < 0) {
      this.url += '.js';
    }
    if (cached[this.url] === true) {
      return this.done(this.id, this.url);
    } else if (started[this.url] != null) {
      return;
    }
    this.el = document.createElement('script');
    this.el.type = 'text/javascript';
    this.el.charset = 'utf-8';
    this.el.async = true;
    this.el.setAttribute('data-id', this.id);
    this.el.src = this.url;
    this.el.onerror = this.error;
    if (this.el.readyState) {
      this.el.onreadystatechange = function(ev) {
        if (_this.el.readyState === 'loaded' || _this.el.readyState === 'complete') {
          _this.el.onreadystatechange = null;
          return _this.internal_done(ev);
        }
      };
    } else {
      this.el.onload = function(ev) {
        return _this.internal_done(ev);
      };
    }
    started[this.url] = true;
    console.log('load..... >> ', this.url);
    head = (document.getElementsByTagName('head'))[0];
    return head.insertBefore(this.el, head.lastChild);
  };

  Script.prototype.internal_done = function(ev) {
    console.log('...loaded << ' + this.url);
    cached[this.url] = true;
    return this.done(this.id, this.el.src, this.is_non_amd);
  };

  return Script;

})();

Chunk = (function() {

  Chunk.chunks_list = [];

  Chunk.chunks = {};

  Chunk.prototype.factored = null;

  function Chunk(type, id, deps, factory, non_amd) {
    this.type = type;
    this.id = id;
    this.deps = deps;
    this.factory = factory;
    this.non_amd = non_amd != null ? non_amd : false;
    if ((this.id != null) && this.id[0] === ':') {
      this.id = this.id.substr(1);
    }
    Chunk.chunks_list.push(this);
  }

  Chunk.notify_all = function(loaded) {
    var chunk, _i, _len, _ref, _results;
    console.log("----------- " + loaded + " ");
    _ref = this.chunks_list;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      chunk = _ref[_i];
      _results.push(chunk.exec(loaded));
    }
    return _results;
  };

  Chunk.prototype.exec = function(loaded) {
    var current, dep, mod, refs, _i, _len, _ref;
    console.log(">>>>> ");
    console.log("id: " + this.id);
    console.log("factored: " + (this.factored != null));
    if ((this.factored != null) || this.non_amd) {
      return this.factored;
    }
    console.log(1);
    if (!this._is_subtree_loaded()) {
      return;
    }
    console.log(2);
    console.log(3);
    console.log('\t <<---- go to go');
    refs = [];
    _ref = this.deps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      if (dep[0] === ':') {
        continue;
      }
      current = Chunk.chunks[dep];
      mod = current.exec(loaded);
      if (mod != null) {
        refs.push(mod);
      }
    }
    if (this.factory instanceof Function) {
      this.factored = this.factory.apply(null, refs);
    } else if (typeof this.factory === 'object') {
      this.factored = this.factory;
    }
    return this.factored;
  };

  Chunk.prototype._is_subtree_loaded = function() {
    var dep, status, _i, _len, _ref;
    status = true;
    _ref = this.deps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      if (dep[0] === ':') {
        dep = dep.substr(1);
      }
      if (this.id === 'app') {
        console.log(">>>>>>>>>>>>>");
        console.log("dep: " + dep);
        console.log("def: " + Chunk.chunks[dep]);
        console.log("ven: " + Chunk.chunks[dep].non_amd);
        console.log("fac: " + Chunk.chunks[dep].factored);
        console.log("<<<<<<<<<<<<<");
      }
      if (Chunk.chunks[dep] != null) {
        dep = Chunk.chunks[dep];
        if (dep.factored === null && dep.non_amd === false) {
          return false;
        }
      } else {
        return false;
      }
    }
    return status;
  };

  return Chunk;

})();

require = function() {
  return Toaster.process('require', [].slice.call(arguments));
};

define = function() {
  return Toaster.process('define', [].slice.call(arguments));
};

Toaster = (function() {

  function Toaster() {}

  Toaster.last_chunk = null;

  Toaster.BASE_URL = null;

  Toaster.MAP = {};

  Toaster.config = function(options) {
    return Toaster.BASE_URL = options.base_url;
  };

  Toaster.map = function(layer_map) {
    return Toaster.MAP = layer_map;
  };

  Toaster.process = function(type, params) {
    var chunk, dep, dep_id, dep_url, is_non_amd, timeout, _i, _len, _ref, _ref1, _results;
    if ((this.last_chunk != null) && this.last_chunk.type === 'require') {
      Toaster.define_chunk('root');
    }
    params = Toaster._name_params(type, params);
    chunk = new Chunk(type, params.id, params.deps, params.factory);
    if (type === 'define' && (chunk.id != null)) {
      Chunk.chunks[chunk.id] = chunk;
    } else {
      this.last_chunk = chunk;
    }
    timeout = 0;
    _ref = params.deps;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      _ref1 = this.disassemble(dep), dep_id = _ref1[0], dep_url = _ref1[1], is_non_amd = _ref1[2];
      if (Chunk.chunks[dep_id] != null) {
        continue;
      }
      _results.push(new Script(dep_id, dep_url, function(id, url, is_non_amd) {
        return Toaster.define_chunk(id, url, is_non_amd);
      }, function(e) {
        return console.error(e);
      }, ++timeout, is_non_amd));
    }
    return _results;
  };

  Toaster.disassemble = function(id) {
    var absolute, is_non_amd, url;
    is_non_amd = false;
    if (id[0] === ':') {
      is_non_amd = true;
      id = id.substr(1);
    }
    if (Toaster.MAP[id] != null) {
      url = Toaster.MAP[id];
    } else {
      url = id;
    }
    if (!(/^http/m.test(url))) {
      absolute = new RegExp("(^" + (Toaster.BASE_URL.replace('/', '\\/')) + ")");
      if (!(absolute.test(url))) {
        url = "" + Toaster.BASE_URL + url;
      }
    }
    if ((url.indexOf('.js')) < 0) {
      url += '.js';
    }
    return [id, url, is_non_amd];
  };

  Toaster.define_chunk = function(id, url, is_non_amd) {
    if (this.last_chunk === null && is_non_amd) {
      return Chunk.chunks[id] = new Chunk('require', id, [], null, true);
    } else if (this.last_chunk != null) {
      this.last_chunk.id = this.last_chunk.id || id;
      if (this.last_chunk.id[0] === ':') {
        this.last_chunk.id = this.last_chunk.id.substr(1);
      }
      Chunk.chunks[this.last_chunk.id] = this.last_chunk;
      return this.last_chunk = null;
    }
  };

  Toaster._name_params = function(type, params) {
    var sorted;
    sorted = {
      id: null,
      deps: null,
      factory: null
    };
    switch (type) {
      case 'require':
        sorted.deps = params[0];
        sorted.factory = params[1] || null;
        break;
      case 'define':
        sorted.factory = params[params.length - 1];
        if (params.length === 3) {
          sorted.id = params[0];
          sorted.deps = [].concat(params[1]);
        } else if (params.length === 2) {
          sorted.deps = [].concat(params[0]);
        } else if (params.length = 1) {
          sorted.deps = [];
        }
    }
    return sorted;
  };

  return Toaster;

})();
