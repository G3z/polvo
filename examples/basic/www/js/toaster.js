// Generated by CoffeeScript 1.4.0
var Chunk, Script, Toaster, define, require;

Script = (function() {
  var cached;

  cached = {};

  Script.prototype.id = null;

  Script.prototype.el = null;

  Script.prototype.url = null;

  Script.prototype.done = null;

  Script.prototype.error = null;

  function Script(id, done, error, timeout) {
    var _this = this;
    this.id = id;
    this.done = done;
    this.error = error;
    setTimeout(function() {
      return _this.load();
    }, timeout);
  }

  Script.prototype.load = function() {
    var head, reg,
      _this = this;
    if (this.id[0] === ':') {
      this.id = this.id.substr(1);
      if (Toaster.MAP[this.id] != null) {
        this.url = Toaster.MAP[this.id];
      } else {
        this.url = this.id;
      }
    }
    if (!/^http/m.test(this.url)) {
      reg = new RegExp("(^" + (Toaster.BASE_URL.replace('/', '\\/')) + ")");
      if (!reg.test(this.id)) {
        this.url = "" + Toaster.BASE_URL + this.id;
      }
    }
    if ((this.url.indexOf('.js')) < 0) {
      this.url += '.js';
    }
    if (cached[this.url] === true) {
      return setTimeout(this.done, 1);
    }
    this.el = document.createElement('script');
    this.el.type = 'text/javascript';
    this.el.charset = 'utf-8';
    this.el.async = true;
    this.el.setAttribute('data-id', this.id);
    this.el.src = this.url;
    this.el.onerror = this.error;
    if (this.el.readyState) {
      this.el.onreadystatechange = function(ev) {
        if (_this.el.readyState === 'loaded' || _this.el.readyState === 'complete') {
          _this.el.onreadystatechange = null;
          return _this.internal_done(ev);
        }
      };
    } else {
      this.el.onload = function(ev) {
        return _this.internal_done(ev);
      };
    }
    head = (document.getElementsByTagName('head'))[0];
    return head.insertBefore(this.el, head.lastChild);
  };

  Script.prototype.internal_done = function(ev) {
    cached[this.url] = true;
    return this.done(this.el.getAttribute('data-id'), this.el.src);
  };

  return Script;

})();

Chunk = (function() {

  Chunk.chunks_list = [];

  Chunk.chunks = {};

  Chunk.prototype.factored = null;

  function Chunk(type, id, deps, factory) {
    this.type = type;
    this.id = id;
    this.deps = deps;
    this.factory = factory;
    if ((this.id != null) && this.id[0] === ':') {
      this.id = this.id.substr(1);
    }
    Chunk.chunks_list.unshift(this);
  }

  Chunk.notify_all = function(loaded) {
    var chunk, _i, _len, _ref, _results;
    _ref = this.chunks_list;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      chunk = _ref[_i];
      if (chunk.factored === null && chunk._is_subtree_loaded()) {
        _results.push(chunk.exec());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Chunk.prototype.exec = function() {
    var current, dep, mod, refs, _i, _len, _ref;
    if (this.factored != null) {
      return this.factored;
    }
    if (!this._is_subtree_loaded()) {
      return;
    }
    if (this.factory == null) {
      return;
    }
    refs = [];
    _ref = this.deps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      if (dep[0] === ':') {
        continue;
      }
      current = Chunk.chunks[dep];
      if ((mod = current.exec()) != null) {
        refs.push(mod);
      }
    }
    if (this.factory instanceof Function) {
      return this.factored = this.factory.apply(null, refs);
    } else if (typeof this.factory === 'object') {
      return this.factored = this.factory;
    } else {
      return this.factored = false;
    }
  };

  Chunk.prototype._is_subtree_loaded = function() {
    var dep, status, _i, _len, _ref;
    status = true;
    _ref = this.deps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      if (dep[0] === ':') {
        dep = dep.substr(1);
      }
      if (Chunk.chunks[dep] != null) {
        dep = Chunk.chunks[dep];
        if (dep.factored === null) {
          return false;
        }
      } else {
        return false;
      }
    }
    return status;
  };

  return Chunk;

})();

Toaster = (function() {

  function Toaster() {}

  Toaster.last_chunk = null;

  Toaster.BASE_URL = null;

  Toaster.MAP = {};

  Toaster.config = function(options) {
    return Toaster.BASE_URL = options.base_url;
  };

  Toaster.map = function(layer_map) {
    return Toaster.MAP = layer_map;
  };

  Toaster.process = function(type, params, load) {
    var s, timeout, _i, _len, _ref, _results;
    if (load == null) {
      load = true;
    }
    if (this.last_chunk != null) {
      Toaster.define_chunk('root');
    }
    params = Toaster._name_params(type, params);
    this.last_chunk = new Chunk(type, params.id, params.deps, params.factory);
    timeout = 0;
    _ref = params.deps;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      _results.push(new Script(s, function(name, url) {
        Toaster.define_chunk(name, url);
        return Chunk.notify_all(name);
      }, function(e) {
        return console.error(e);
      }, ++timeout));
    }
    return _results;
  };

  Toaster.define_chunk = function(name, url) {
    if (this.last_chunk != null) {
      this.last_chunk.id = name = this.last_chunk.id || name;
    } else {
      this.last_chunk = new Chunk('require', name, [], {});
    }
    if (this.last_chunk.id[0] === ':') {
      this.last_chunk.id = this.last_chunk.id.substr(1);
    }
    Chunk.chunks[this.last_chunk.id] = this.last_chunk;
    return this.last_chunk = null;
  };

  Toaster._name_params = function(type, params) {
    var sorted;
    sorted = {
      id: null,
      deps: null,
      factory: null
    };
    switch (type) {
      case 'require':
        sorted.deps = params[0];
        sorted.factory = params[1] || null;
        break;
      case 'define':
        sorted.factory = params[params.length - 1];
        if (params.length === 3) {
          sorted.id = params[0];
          sorted.deps = [].concat(params[1]);
        } else if (params.length === 2) {
          sorted.deps = [].concat(params[0]);
        } else if (params.length = 1) {
          sorted.deps = [];
        }
    }
    return sorted;
  };

  return Toaster;

})();

require = function() {
  return Toaster.process('require', [].slice.call(arguments));
};

define = function() {
  return Toaster.process('define', [].slice.call(arguments));
};



// initializing project `browser-sample`
(function(){
  Toaster.map( {jquery:'https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js'} );
  Toaster.config( {base_url: 'js/'} );
  require( ['app/app'] );
})()